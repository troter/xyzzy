テストの実行方法
================
テストを実行するには

1. unittest/simple-test.l （テストのフレームワークや便利マクロなど）を読み込む
  - 普通の lisp ファイルとして読み込みます
2. `M-x load-test-file` から実行したいテストの書いてあるファイルを読み込む
3. 以下のどれかで実行する
  - `M-x run-all-tests` - 読み込んだテストを全て実行
  - `M-x run-tests-from-file` - 指定したファイルから読み込んだテストを実行
  - `M-x run-tests` - 前回実行したテストをもっかい実行

すると "*Test Results*" というバッファに色々出てきます。最期の行に "ALL passed" とか "0 failed" とか表示されていればオッケーです。

全てのテストを実行するのであれば unittest/run-all.l を `eval-buffer` や `load-file` やコマンドラインの "-l" オプションで読み込むのがカンタンです。

注意事項
--------
（後で書く）


テストの書き方
==============
テストは unittest/ 以下のてきとーなファイルに書きます。
簡単なものなら lisp-tests.l に追加、たくさんテストを書く場合は専用のテストファイル作っちゃってください。

個々のテストは `deftest` で書きます。こんな感じです。

    (deftest テストの名前 (オプション)
      "説明文字列"
      テストする式
      => 正しい戻り値)

オッケーなら non-nil を返す
---------------------------
`テストする式` が真（non-nil）を返せばオッケー、という場合は戻り値などを書く必要は無く、`テストする式` だけ書いておきます。

    (deftest 1-is-not-zero ()
      (not (zerop 1)))


戻り値のテスト
--------------
`テストする式` がこの値を返せばオッケーという場合は `=> 正しい戻り値` と書きます。

    (deftest 1+2=3 ()
      (+ 1 2)
      => 3)

`正しい戻り値` と実際の戻り値は `equal` で比較されます。比較関数を指定したい場合は `オプション` に `:compare 比較関数` とか書いておきます。

    (deftest 1+2=3 (:compare =)
      (+ 1 2)
      => 3)

多値を返す場合は `=> 正しい戻り値` を実際に返ってくるだけ並べるだけです。
（暫定）`テストする式` はきっちり指定された数の戻り値を返さないとダメです。多くても少なくてもダメです。

    (deftest a-b-c ()
      "a と b と c を返す"
      (values 'a 'b 'c)
      => a
      => b
      => c)

### 細かい説明
- 比較関数は評価されないので、関数名（シンボル）か `#'` なしのラムダ式を書いておく。
- 比較関数には `正しい戻り値` と実際の戻り値が渡されます（この順番で）。
- `正しい戻り値` は評価されないので、比較関数で頑張るか `#.(...)` で何とかする。
- 実際の戻り値はきっちり指定された数の値（多値的な意味で）を返さないとダメです。


出力のテスト
------------
`テストする式` が `*standard-output*` などに何か書き出せばオッケーという場合は `>> 正しい出力` と書きます。

    (deftest hello-00 ()
      (princ "hello")
      >> hello
      => "hello")

出力先を指定するには `オプション` に `:output 出力先` とか書いておきます。

    (deftest hello-01 (:output *trace-output*)
      (princ "hello" *trace-output*)
      >> hello
      => "hello")

### 細かい説明
- 実装上の都合で出力先の指定はシンボルをクォートせずに書く必要があります。
- `>> `（スペースを含む）から改行までが正しい出力です。
- 複数行の場合は `>> 出力` を複数行に渡って書きます。
- 最期に改行する場合は、空の `>> ` を書いておきます。
- 出力だけを書いて戻り値を書かなかった場合、オッケーなら non-nil を返すものと解釈されます。`nil` を返す場合は `=> nil` と書く必要があります。
  - non-nil を返す場合は戻り値を省略できますが、`deftest` の終わりの閉じカッコは新しい行に書く必要があります。（そうしないと出力の一部とされてしまう。）

めんどい例:

    (deftest hello-02 ()
      (format t "hello~%hello~%")
      >> hello
      >> hello
      >> 
      => nil)

マクロ展開のテスト
------------------
`テストする式` がマクロ呼び出しで、特定の式に展開されればオッケーという場合は `== 展開後の式` と書きます。

    (deftest setf-to-setq ()
      "シンボルへの setf は setq に展開される"
      (setf x 1)
      == (setq x 1)
      => 1)

`展開後の式` に uninterned symbol（`#:G0381` みたいなの）があると、実際の展開形の同じ場所には uninterned symbol があればオッケーになります。`gensym` で一時変数を作ってる場合に使います。

### 細かい説明
- `テストする式` を `macroexpand-1` か `macroexpand` のどちらかで展開した結果が `展開後の式` と一致すればオーケー。
- マクロ展開の期待を書いたのに `テストする式` がマクロ展開されない場合は fail します。
- （暫定）今のところレキシカル環境には対応してない。

説明文字列について
------------------
テスト実行してダメだった場合にダメだった詳細と一緒に表示されます。何のテストなのかわかりやすい説明を書いとくとダメだったときに助かるのでなるべくなら書いておいて欲しいですが、めんどかったら省略できます。

